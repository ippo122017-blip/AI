# サーキットタイマー アプリ要件・設計ドキュメント（モバイル展開準備）

最終更新: 2025-12-06

## 1. 背景と目的
- 既存: `python/circuit_timer.py`でCLI/Tkinter UIを提供し、ローカルJSON(`menus.json`)にメニューを保存。
- 課題: PC前提UIのため、ジムや自宅トレ中は扱いにくく、通知/振動/バックグラウンド実行に非対応。
- 目的: iOS/Androidで同等以上の体験（通知・振動・音・バックグラウンド実行）を提供し、将来的に他デバイスともデータ共有できる構成へ拡張する。
- 成果物: 本ドキュメントは要件定義＋基本設計のハイブリッド版。今後タスク化や詳細設計を書く際の参照元とする。

## 2. 用語と略語
- **Menu**: トレーニング設定（名前、作業秒数、休憩秒数、セット数）。
- **Phase**: 作業または休憩の1区間。
- **MVP**: Minimum Viable Product。初版モバイルアプリ。
- **Local DB**: 端末ローカル永続化。iOS: CoreData/SQLite、Android: Room/SQLite。

## 3. 成功指標 (KPI)
| 指標 | MVP目標 | 備考 |
|------|---------|------|
| 1週間継続率 | 60% | ベータユーザー対象 | 
| タイマー精度誤差 | ±0.1秒以内/分 | OS制約内で調整 |
| クラッシュ率 | 1%未満 | 端末別に監視 |
| メニュー作成完了率 | 90% | 初回起動チュートリアル含む |

## 4. ステークホルダー
- **エンドユーザー**: 自宅やジムでサーキットトレを行う個人ユーザー。
- **プロダクトオーナー**: 現アプリ開発者（本プロジェクトオーナー）。
- **サポート役**: 将来のデザイナー、クラウドエンジニア（必要に応じてアサイン）。

## 5. ユーザーストーリー
1. ユーザーとして、事前に登録したメニューをスマホで素早く選びタイマーを開始したい（F-01, F-02）。
2. ユーザーとして、スマホ画面を見ずに通知音や振動で次のフェーズを把握したい（F-03）。
3. ユーザーとして、トレーニング履歴を振り返りたい（F-04）。
4. 将来: 複数デバイスで同じメニューを共有したい（F-05）。

## 6. 想定利用シーン
1. 自宅トレ中: 画面ロック中でも通知/振動でフェーズを認識。
2. 複数デバイス: タブレットで編集→スマホで実行。
3. インターバル切り替え時に視覚/聴覚/触覚でフィードバック。

## 7. 要件定義

### 7.1 機能要件
| ID | 要件 | 優先度 | 受入条件の例 |
|----|------|--------|---------------|
| F-01 | トレーニングメニューのCRUD（名称/セット秒数/休憩秒数/セット数） | Must | 新規/編集/削除がアプリ上で完結し、JSONインポート/エクスポートで互換性維持 |
| F-02 | タイマー再生/一時停止/停止/再開 | Must | 画面表示・通知・進捗バーが同期し、バックグラウンドでも正確に進行 |
| F-03 | 作業/休憩の音・振動通知 | Should | 端末の設定と連動し、ユーザーがON/OFFや音量を切り替え可能 |
| F-04 | 記録保存（履歴、完了日時、完了セット数） | Should | 履歴一覧から当日の完了状況が確認できる |
| F-05 | アカウント／同期（将来） | Could | 認証後に複数端末でメニューと履歴が統一される |
| F-06 | 多言語対応（JP/EN） | Could | 端末言語に応じ自動切替し、手動選択も可能 |
| F-07 | インポート/エクスポート機能 | Should | 既存`menus.json`を読み込み、新形式で書き出せる |
| F-08 | チュートリアル/オンボーディング | Should | 初回起動で基本操作を案内し、完了後に再表示しない |

### 7.2 非機能要件
- **レスポンス**: 画面遷移/操作への応答は200ms以内、タイマーは±100ms精度。
- **可用性**: オフライン完結、同期追加後もオフライン時にメニュー閲覧/実行可能。
- **アクセシビリティ**: コントラスト比4.5:1以上、ボタンタップ領域44px以上、VoiceOver/TalkBack対応。
- **セキュリティ**: 同期実装時はHTTPS+認証トークン。ローカル保存はOS標準ストレージ。
- **耐障害性**: アプリ再起動後も直前のタイマー状態を復元（残り時間/進行セット）。
- **運用性**: アプリ内でバージョン/ビルド番号とフィードバック導線を表示。

### 7.3 変更管理
- タスクやチケットには対応する要件ID(F-xx)を紐付ける。
- 変更が発生した場合、本ドキュメントの該当節を更新し「最終更新日」「担当」を記録。

## 8. 制約・前提
- MVPは端末ローカルDB（例: SQLite/Room/CoreData）で完結。
- Python版資産はビジネスロジックの参照用途。最終的なモバイル実装はネイティブまたはクロスプラットフォーム（Flutter/React Native等）で再構築。
- `menus.json`互換のスキーマ（name, set_seconds, rest_seconds, sets）を維持し、移行スクリプトを提供。
- バックグラウンド実行は各OSのガイドラインに準拠。

## 9. アーキテクチャ方針
- **プレゼンテーション層**: モバイルUI（候補: Flutter）で画面を定義。状態管理はRiverpod/Bloc等を想定。
- **ドメイン層**: `TrainingMenu`, `TimerSequence`, `TimerController`などをUIから分離し、単体テスト可能にする。
- **データ層**:
  - MVP: 端末ローカルDBでメニュー永続化。
  - 将来: REST/GraphQL/API Gatewayを介してクラウド同期（AWS Amplify/Firebase候補）。
- **通知層**: OS通知・振動APIをカバーする抽象化を提供。
- **構成図（テキスト）**:  `UI画面` ⇄ `状態管理(ViewModel)` ⇄ `ドメインサービス(タイマー/メニュー)` ⇄ `リポジトリ` ⇄ `ローカルDB/同期API`

## 10. データ設計詳細
### 10.1 エンティティ
| テーブル | 主キー | 属性 | 備考 |
|----------|--------|------|------|
| menus | uuid | name, set_seconds, rest_seconds, sets, created_at, updated_at | nameユニーク制約 |
| sessions | uuid | menu_id(FK), started_at, completed_sets, duration_seconds, notes | 履歴画面用 |
| settings | singleton | locale, notification_pref, vibration_pref | 端末設定と同期 |

### 10.2 移行
- 初回起動で`menus.json`を取り込み`menus`テーブルに変換。
- エクスポート時はJSON互換フォーマットで書き出す。

## 11. 画面/UX仕様
1. **ホーム/メニュー一覧**: メニューカード表示、検索、選択で詳細パネル表示、FABで新規作成。
2. **メニュー編集**: 名前・作業/休憩時間・セット数を入力。バリデーション: 1〜600秒、セット数1〜20。
3. **タイマー画面**: 残り時間、現在セット/総セット表示、進捗バー、再生/一時停止/停止/スキップボタン。
4. **履歴画面（後続）**: 日付別リスト、セッション詳細。
5. **設定画面**: 通知ON/OFF、サウンド/バイブ種類、言語切替、データのインポート/エクスポート。

## 12. タイマー挙動
```
Idle -> Running -> (Paused <-> Running) -> Completed
                    \-> Stopped -> Idle
```
- Running中は1秒ごとにPhaseを減算。バックグラウンド時はOSタイマー/APIで継続し、復帰時に同期。
- Phase遷移時に通知・サウンド・振動を発火。ユーザー設定で種類を切替。
- エラー時はタイマーを停止し、再開方法を表示。

## 13. ストレージ/API仕様（MVP）
- ローカル保存形式: SQLite/Room/CoreData（プラットフォーム依存）。
- JSON入出力スキーマ: `[ {"name": str, "set_seconds": int, "rest_seconds": int, "sets": int } ]`
- 同期構想（将来）: `/api/menus` GET/POST/PUT/DELETE、`/api/sessions` GET/POST。

## 14. ロードマップ
1. **ドメイン分離**: 既存Pythonのタイマー/メニュー処理をクラス化しUI依存を排除。
2. **技術選定 & PoC**: Flutter/React Native等でタイマー精度・通知制約を検証（別ドキュメント参照）。
3. **MVP実装**: ローカル保存＋通知対応を完了し、テストフライト/内部テストで配布。
4. **同期/履歴強化**: クラウドAPI導入、複数デバイス同期と履歴分析。
5. **公開準備**: 多言語対応、プライバシーポリシー、アプリ審査要件整備。

## 15. 運用・更新方針
- 変更要求はIssue/Ticketに起票し、該当要件IDを明記。
- 本ドキュメント更新時は「最終更新日」「担当」「要約」を先頭に追記。
- 新メンバーオンボーディング資料として利用し、セットアップ手順や関連リポジトリへのリンクを付録化予定。

## 16. リスクと課題
| ID | 内容 | 影響 | 対策案 |
|----|------|------|--------|
| R-01 | iOSのバックグラウンド実行制限 | タイマー停止/遅延 | ローカル通知スケジューリング＋BGTaskで補完 |
| R-02 | Androidメーカー独自省電力 | 通知遅延 | Foreground Service化を検討 |
| R-03 | 同期API未整備 | 多端末ニーズ未充足 | MVPはローカルで割り切り、設計のみ先行 |
| R-04 | 個人開発によるリソース不足 | 機能遅延 | Must/Should優先づけを厳守し段階的に実装 |

## 17. 今後のドキュメントタスク
- [完了] 画面遷移図・ワイヤーフレーム（docs/mobile_timer_ux_and_test.md#1）
- 詳細API設計（エンドポイント、ペイロード例）
- [完了] テスト計画（docs/mobile_timer_ux_and_test.md#3）
- リスク登録表の定期レビュー
- [進行中] 技術選定メモ更新（docs/mobile_timer_tech_selection.md, docs/flutter_timer_poc_plan.md）

---
本ドキュメントはモバイル展開に向けた詳細整理です。実装フェーズ前後で必ず見直し、要件との乖離を防止してください。
